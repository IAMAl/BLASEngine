# Convolution Note

BLASEngineは畳み込み演算をサポートしています。下の図はカーネルサイズK=3でデライト幅D=1の時の重みwベクトル要素と入力ベクトルx要素の対応を示しています。入力ベクトルxは左に位置していて重みwは右に位置して図示しています。A，B、C各列での重み要素の位置は下方向にローテートして配置しています。入力ベクトルの要素は各タイミングで右へ移動して合流した重み要素とで乗算を行います。ストライド量S=1の時はA、B，Cの3並列で畳み込みができます。Bの列はAで利用した入力ベクトルを受け取り乗算を行います。Cの列も同様です。乗算結果は下方向に送り累和処理を行います。その累和処理の方法は2通りあります。一つは各乗算に併せてその後に加算を行うMAD(Multiply-Add)構成で、演算結果としてA，B、Cの各列は畳み込み演算結果の要素を出力します。二つ目の方法は乗算結果を転送しますが加算はしないで出力段まで転送します。出力段にアキュムレータ（累和器）を設置しておいてそこで累和をする方法もあります。


<div align="center">
  <img src="https://github.com/IAMAl/BLASEngine/blob/main/notes/ExecConcept/figures/1DConvK3D1.png"
       alt="HTML image alt text"
       title="1D Convolution (K=3, Delite=1)"
       width="700px"
  />
</div>


下の図はD=2の場合の畳み込み演算のパターンです。D=1と比べると入力ベクトル要素の並びとストライド量Ｓに対する並列処理数のパターンが違います。ストライド量S=1の時6並列で処理ができます。


<div align="center">
  <img src="https://github.com/IAMAl/BLASEngine/blob/main/notes/ExecConcept/figures/1DConvK3D2.png"
       alt="HTML image alt text"
       title="1D Convolution (K=3, Delite=2)"
       width="700px"
  />
</div>


このように畳み込み演算はストライド量に応じた並列処理が可能であり、その際に読み出した入力ベクトルの要素を再利用できます。この並列処理数つまり最大再利用回数Lは下図の式で表すことができます。カーネルサイズK、ストライド量S、デライト量Dで並列処理数Lが決まります。
また、並列に処理する際の重みの下方向へのローテート量Bも式で表すことができます。
入力ベクトルXについて各行iでのインデックス値とその行iでのインデックスの変化量（ストライド量）はオフセット量eと別のストライド量Sで定義できます。


<div align="center">
  <img src="https://github.com/IAMAl/BLASEngine/blob/main/notes/ExecConcept/figures/ConvConfigParams.png"
       alt="HTML image alt text"
       title="Parameters for Convolution"
       width="550px"
  />
</div>


このような畳み込み演算をBLASEngineで実装する際2つの方法があります。


#### 方法1：WとXを固定

一つ目の方法はシストリックアレイ相当の方法です。要素は各レーンで固定した配置とします。入力ベクトルと重みの位置について要素を固定します。つまりA、B、Cを横断した一つの行がレーンにマップされます。そして乗算結果をネットワークを使用して隣接する右隣のレーンへ渡して累和を行います。この場合MADの3項演算命令を前提とします。


#### 方法2：Wを固定

もう一つの方法は重みだけ固定します。これはA、B、Cそれぞれの列がレーンにマップされます。レジスタファイルから読み出した入力ベクトル要素はネットワークを通してローテート転送して他のレーンへ入力して再利用します。この場合もMADの3項演算命令を前提とします。


#### BLASEngineのメリット

各レーンにある入力ベクトルの部分ベクトルを再配置する必要がなくなり、例えば次の演算において現在の演算結果ベクトルの各要素を各レーンへ再配置することを不要としてベクトル演算ユニットの演算器は演算のみに集中でき、無駄な処理を削減します。