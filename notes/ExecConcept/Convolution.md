# Convolution Note

BLASEngineは畳み込み演算をサポートしています。下の図はカーネルサイズK=3でデライト幅D=1の時の重みｗベクトル要素と入力ベクトルｘ要素の対応を示しています。入力ベクトルｘは左に位置していて重みｗは右に位置して図示しています。Ａ，Ｂ、Ｃ各列での重み要素の位置は下方向にローテートして配置しています。入力ベクトルの要素は各タイミングで右へ移動して合流した重み要素を乗算を行います。ストライド量S=1の時はＡ、Ｂ，Ｃの3並列で畳み込みができます。Ｂの列はＡで利用した入力ベクトルを受け取り乗算を行います。Ｃの列も同様です。乗算結果は下方向に送り類話処理を行います。類話処理の方法は2通りあります。一つは各乗算に併せてその後に加算を行うMAD(Multiply-Add)構成で、演算結果としてＡ，Ｂ、Ｃの各列は畳み込み演算結果の要素を出力します。二つ目の方法は乗算結果を転送しますが乗算はしないで出力団まで転送します。出力団にアキュムレータ（類話気）を設置しておいてそこで類話をする方法もあります。


<div align="center">
  <img src="https://github.com/IAMAl/BLASEngine/blob/main/notes/ExecConcept/1DConvK3D1.png"
       alt="HTML image alt text"
       title="1D Convolution (K=3, Delite=1)"
       width="700px"
  />
</div>


下の図はD=2の場合の畳み込み演算のパターンです。D=1と比べると入力ベクトル要素の並びとストライド量Ｓに対する並列処理数のパターン、そして各乗算の竜力の際の入力ベクトル要素を使用するかただ転送するだけかが違います。例えばストライド量S=3の時Ａの列は入力ベクトル要素x2を使用せず右へ転送します。転送されたその要素はＢ列で使用します。


<div align="center">
  <img src="https://github.com/IAMAl/BLASEngine/blob/main/notes/ExecConcept/1DConvK3D2.png"
       alt="HTML image alt text"
       title="1D Convolution (K=3, Delite=1)"
       width="700px"
  />
</div>


このように畳み込み演算はストライド量に応じた並列処理が可能であり、その際に読み出した入力ベクトルの要素を再利用できます。この並列処理数Ｌは下図の式で表すことができます。カーネルサイズＫ、ストライド量Ｓ、デライト量Ｄで並列処理数Ｌが決まります。
また、並列に処理する際の重みの下方向へのローテート量Ｂも式で表すことができ下図で示していまっす。
入力ベクトルＸについて各行iでのインデックス値とその行iでのインデックスの変化量（ストライド量）はオフセット量eと別のストライド量Ｓで定義でき、それもした図に示しています。


<div align="center">
  <img src="https://github.com/IAMAl/BLASEngine/blob/main/notes/ExecConcept/ConvConfigParams.png"
       alt="HTML image alt text"
       title="1D Convolution (K=3, Delite=1)"
       width="550px"
  />
</div>


このような畳み込み演算をBLASEngineで実装する際2つの方法があります。


#### 方法1：WとXを固定

一つ目の方法はシストリックアレイ相当の方法で入力クトルと重みの位置について要素を固定します。そして乗算結果をネットワークを使用して隣接する右隣のレーンへ渡して累和を行います。この場合MADの3項演算命令を前提とします。


#### 方法2：Wを固定

もう一つの方法は重みだけ固定します。レジスタファイルから読み出した入力ベクトル要素はネットワークを通してローテート転送して他のレーンへ入力して再利用します。この場合もMADの3項演算命令を前提とします。


#### BLASEngineのメリット

各レーンにある入力ベクトルの部分ベクトルを再配置する必要がなくなり、たとえな次の演算において演算結果ベクトルの各要素について各レーンへの再配置を不要としてベクトル演算ユニットの演算器は演算のみに集中できます。